edge_threshold = .8, mark_threshold = .5)
# Create complete dag from the bootstrap analysis
make_averaged_bootstrap_graph(bootstrap_arrowheads, bootstrap_tails, bootstrap_circles, bootstrap_edges,
edge_threshold = .8, mark_threshold = .5)
# Create complete dag from the bootstrap analysis
make_averaged_bootstrap_graph(bootstrap_arrowheads, bootstrap_tails, bootstrap_circles, bootstrap_edges,
edge_threshold = .8, mark_threshold = .5)
intelligenz <- runif(20,80, 120)
intelligenz
intelligenz <- runif(20,80, 120)
intelligenz
intelligenz <- runif(20,80, 120)
intelligenz
intelligenz <- runif(20,80, 120)
intelligenz <- runif(20,80, 120)
intelligenz
server <- function(input, output) {
target_word <- reactiveVal(sample(german_words, 1))
all_guesses <- reactiveVal(list())
finished <- reactiveVal(FALSE)
current_guess_letters <- reactiveVal(character(0))
reset_game <- function() {
target_word(sample(german_words, 1))
all_guesses(list())
finished(FALSE)
}
a
)
output$result <- renderText({
if (! input$guess %in% words_all) {
req(FALSE, cancelOutput = TRUE)
}
result <- check_words(target, input$guess)
format_result(result)
}) |>
bindEvent(input$go)
library(shiny)
setwd("/Users/jessi/Desktop/Jessi/Uni/Master/4.Semester/Programming 2/My own wordle")
source("Wordlist.R")
ui <- fluidPage(
textInput("guess", ""),
actionButton("go", "Go"),
verbatimTextOutput("result", placeholder = TRUE),
)
library(shiny)
source("Wordlist.R")
ui <- fluidPage(
textInput("guess", ""),
actionButton("go", "Go"),
verbatimTextOutput("result", placeholder = TRUE),
)
# Set the random seed based on the date, so that the same word is used during
# each day.
set.seed(as.integer(Sys.Date()))
target <- sample(words_common, 1)
if (! input$guess %in% german_words) {
req(FALSE, cancelOutput = TRUE)
}
server <- function(input, output) {
output$result <- renderText({
if (! input$guess %in% german_words) {
req(FALSE, cancelOutput = TRUE)
}
result <- check_words(target, input$guess)
format_result(result)
}) |>
bindEvent(input$go)
}
# Week 1 functions
library(shiny)
source("Wordlist.R")
ui <- fluidPage(
textInput("guess", ""),
actionButton("go", "Go"),
verbatimTextOutput("result", placeholder = TRUE),
)
target <- sample(german_words, 1)
server <- function(input, output) {
output$result <- renderText({
if (! input$guess %in% german_words) {
req(FALSE, cancelOutput = TRUE)
}
result <- check_words(target, input$guess)
format_result(result)
}) |>
bindEvent(input$go)
}
format_result <- function(r) {
out_str <- ""
for (i in seq_along(r$letters)) {
if (r$result[i] == "correct") {
out_str <- paste0(out_str, "[", r$letters[i], "]")
} else if (r$result[i] == "in-word") {
out_str <- paste0(out_str, "(", r$letters[i], ")")
} else {
out_str <- paste0(out_str, " ", r$letters[i], " ")
}
}
out_str
}
# target: "gives"
# guess:  "aisle"
compare_words <- function(target_str, guess_str) {
if (nchar(target_str) != nchar(guess_str)) {
stop("target and guess string must be the same length.")
}
target <- strsplit(target_str, "")[[1]]
guess <- strsplit(guess_str, "")[[1]]
result <- character(nchar(guess_str))
for (i in seq_along(target)) {
if (guess[i] == target[i]) {
result[i] <- "correct"
} else if (guess[i] %in% target) {
result[i] <- "in-word"
} else {
result[i] <- "not-in-word"
}
}
result
}
check_words <- function(target_str, guess_str) {
compare_result <- compare_words(target_str, guess_str)
correct <- FALSE
if (all(compare_result == "correct")) {
correct <- TRUE
}
list(
word = guess_str,
letters = strsplit(guess_str, "")[[1]],
result = compare_result,
correct = correct
)
}
shinyApp(ui, server)
target <- sample(german_words, 1)
target <- sample(german_words, 1)
target <- sample(german_words, 1)
compare_words <- function(target_str, guess_str) {
if (nchar(target_str) != nchar(guess_str)) {
stop("target and guess string must be the same length.")
}
target <- strsplit(target_str, "")[[1]]
guess <- strsplit(guess_str, "")[[1]]
result <- character(nchar(guess_str))
for (i in seq_along(target)) {
if (guess[i] == target[i]) {
result[i] <- "correct"
} else if (guess[i] %in% target) {
result[i] <- "in-word"
} else {
result[i] <- "not-in-word"
}
}
result
}
compare_words(hello)
compare_words("hello")
compare_words("hello", "hello")
compare_words("hello", "Baume")
compare_words("hello", "melone")
compare_words("hello", "melon")
compare_words(, "melon")
runApp('German_Wordle.R')
library(shiny)
library(htmltools)
# Use wordlist
source("Wordlist.R")
# Build UI in shiny
ui <- fluidPage(
theme = bslib::bs_theme(version = 4),
title = "German Wordle",
tags$style(HTML("
.container-fluid {
text-align: center;
height: calc(100vh - 30px);
display: grid;
grid-template-rows: 1fr auto;
}
.guesses {
overflow-y: auto;
height: 100%;
}
.guesses.finished {
overflow-y: visible;
}
.guesses .word {
margin: 5px;
}
.guesses .word > .letter {
display: inline-block;
width: 50px;
height: 50px;
text-align: center;
vertical-align: middle;
border-radius: 3px;
line-height: 50px;
font-size: 32px;
font-weight: bold;
user-select: none;
color: white;
font-family: 'Clear Sans', 'Helvetica Neue', Arial, sans-serif;
}
.guesses .word > .correct {
background-color: #6a5;
}
.guesses .word > .in-word {
background-color: #db5;
}
.guesses .word > .not-in-word {
background-color: #888;
}
.guesses .word > .guess {
color: black;
background-color: white;
border: 1px solid black;
}
.keyboard {
height: 240px;
user-select: none;
}
.keyboard .keyboard-row {
margin: 3px;
}
.keyboard .keyboard-row .key {
display: inline-block;
padding: 0;
width: 30px;
height: 50px;
text-align: center;
vertical-align: middle;
border-radius: 3px;
line-height: 50px;
font-size: 18px;
font-weight: bold;
background-color: #ddd;
}
.keyboard .keyboard-row .key.wide-key {
font-size: 15px;
width: 50px;
}
.keyboard .keyboard-row .key.correct {
background-color: #6a5;
color: white;
}
.keyboard .keyboard-row .key.in-word {
background-color: #db5;
color: white;
}
.keyboard .keyboard-row .key.not-in-word {
background-color: #888;
color: white;
}
.endgame-content {
font-family: Helvetica, Arial, sans-serif;
display: inline-block;
line-height: 1.4;
letter-spacing: .2em;
margin: 20px 8px;
width: fit-content;
padding: 20px;
border-radius: 5px;
box-shadow: 4px 4px 19px rgb(0 0 0 / 17%);
}
.title {
font-size: 4em;
margin-bottom: 20px;
}
.description {
margin-bottom: 20px;
}
")),
div(
class = "guesses",
h1("German Wordle", class = "title"),
p("Guess the Wordle in 6 tries.", class = "description"),
p("Each guess must be a valid German 5-letter word.", class = "description"),
p("The color of the tiles will change to show how close your guess was to the word.", class = "description"),
uiOutput("previous_guesses"),
uiOutput("current_guess"),
uiOutput("endgame"),
uiOutput("new_game_ui")
),
uiOutput("keyboard"),
tags$script(HTML("
const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
const all_key_ids = [...letters, 'Enter', 'Back'];
document.addEventListener('keydown', function(e) {
let key = e.code.replace(/^Key/, '');
if (letters.includes(key)) {
document.getElementById(key).click();
} else if (key == 'Enter') {
document.getElementById('Enter').click();
} else if (key == 'Backspace') {
document.getElementById('Back').click();
}
});
document.addEventListener('touchstart', function(e) {
if (all_key_ids.includes(e.target.id)) {
e.target.click();
e.target.style.pointerEvents = 'none';
e.preventDefault();
}
});
document.addEventListener('touchend', function(e) {
all_key_ids.forEach(id => {
document.getElementById(id).style.pointerEvents = null;
});
});
"))
)
# Server function
server <- function(input, output) {
target_word <- reactiveVal(sample(german_words, 1))
all_guesses <- reactiveVal(list())
finished <- reactiveVal(FALSE)
current_guess_letters <- reactiveVal(character(0))
reset_game <- function() {
target_word(sample(german_words, 1))
all_guesses(list())
finished(FALSE)
}
observeEvent(input$Enter, {
if (finished()) return()
guess <- paste(current_guess_letters(), collapse = "")
if (!guess %in% german_words) return()
check_result <- check_word(guess, target_word())
all_guesses(append(all_guesses(), list(check_result)))
if (check_result$win || length(all_guesses()) >= 6) finished(TRUE)
current_guess_letters(character(0))
})
output$previous_guesses <- renderUI({
res <- lapply(all_guesses(), function(guess) {
div(class = "word", lapply(guess$letters, function(letter, match) {
div(toupper(letter), class = paste("letter", match))
}, guess$matches))
})
tagList(res, tags$script(HTML("document.querySelector('.guesses').scrollTo(0, document.querySelector('.guesses').scrollHeight);")))
})
output$current_guess <- renderUI({
if (finished()) return()
letters <- current_guess_letters()
target_length <- nchar(target_word())
if (length(letters) < target_length) letters[(length(letters) + 1):target_length] <- ""
div(class = "word", lapply(letters, function(letter) {
div(toupper(letter), class = "letter guess")
}))
})
output$new_game_ui <- renderUI({
if (!finished()) return()
actionButton("new_game", "New Game")
})
observeEvent(input$new_game, { reset_game() })
used_letters <- reactive({
letter_matches <- list()
lapply(all_guesses(), function(guess) {
mapply(function(letter, match) {
prev_match <- letter_matches[[letter]]
if (is.null(prev_match) || match == "correct" || (match == "in-word" && prev_match == "not-in-word")) {
letter_matches[[letter]] <- match
}
}, guess$letters, guess$matches)
})
letter_matches
})
keys <- list(
c("Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"),
c("A", "S", "D", "F", "G", "H", "J", "K", "L"),
c("Enter", "Z", "X", "C", "V", "B", "N", "M", "Back")
)
output$keyboard <- renderUI({
prev_match_type <- used_letters()
keyboard <- lapply(keys, function(row) {
div(class = "keyboard-row", lapply(row, function(key) {
class <- "key"
if (!is.null(prev_match_type[[tolower(key)]])) class <- paste(class, prev_match_type[[tolower(key)]])
if (key %in% c("Enter", "Back")) class <- paste(class, "wide-key")
actionButton(key, key, class = class)
}))
})
div(class = "keyboard", keyboard)
})
lapply(unlist(keys), function(key) {
observeEvent(input[[key]], {
if (finished()) return()
cur <- current_guess_letters()
if (length(cur) >= 5) return()
current_guess_letters(c(cur, tolower(key)))
})
})
observeEvent(input$Back, {
current_guess_letters(current_guess_letters()[-length(current_guess_letters())])
})
output$endgame <- renderUI({
if (!finished()) return()
div(class = "endgame-content",
lapply(all_guesses(), function(guess) {
div(paste(vapply(guess$matches, function(match) {
switch(match, correct = "🟩", in_word = "🟨", not_in_word = "⬜")
}, character(1)), collapse = ""))
}),
h4(paste("The correct word was:", toupper(target_word())))
)
})
}
check_word <- function(guess_str, target_str) {
guess <- strsplit(guess_str, "")[[1]]
target <- strsplit(target_str, "")[[1]]
result <- rep("not-in-word", length(guess))
remaining <- setdiff(target, guess[target == guess])
for (i in seq_along(guess)) {
if (guess[i] == target[i]) result[i] <- "correct"
}
for (i in seq_along(guess)) {
if (guess[i] != target[i] && guess[i] %in% remaining) {
result[i] <- "in-word"
remaining <- setdiff(remaining, guess[i])
}
}
list(
word = guess_str,
letters = guess,
matches = result,
win = all(result == "correct")
)
}
shinyApp(ui, server)
setwd("/Users/jessi/Desktop/Jessi/Uni/Master/4.Semester/Programming 2/Week 2")
install.packages('devtools')
install.packages('roxygen2')
install.packages('usethis')
install.packages("devtools")
library(devtools)
library(roxygen2)
library(usethis)
# 1. create the R package skeleton, choose a name for your R package
devtools::create('GermanWordle')
setwd("/Users/jessi/Desktop/Jessi/Uni/Master/4.Semester/Programming 2/Week 2/GermanWordle")
# # 2. add a license
usethis::use_ccby_license()
# 4.1 Define which functions should be available to your users
# use "#' @export" for that, add it to your .R function file
# 4.2 Use the document() function to make the functions available
# to users
devtools::document()
# 4.1 Define which functions should be available to your users
# use "#' @export" for that, add it to your .R function file
# 4.2 Use the document() function to make the functions available
# to users
devtools::document()
# 4.1 Define which functions should be available to your users
# use "#' @export" for that, add it to your .R function file
# 4.2 Use the document() function to make the functions available
# to users
devtools::document()
# 6. build your package
# creates an installable file with ending "tar.gz"
devtools::build()
# 7. your package can now be installed (by you and others!)
rm(list = ls())
devtools::install()
library(GermanWordle)
devtools::install()
library(GermanWordle)
# 4.1 Define which functions should be available to your users
# use "#' @export" for that, add it to your .R function file
# 4.2 Use the document() function to make the functions available
# to users
devtools::document()
setwd("/Users/jessi/Desktop/Jessi/Uni/Master/4.Semester/Programming 2/Week 2/GermanWordle")
# 4.1 Define which functions should be available to your users
# use "#' @export" for that, add it to your .R function file
# 4.2 Use the document() function to make the functions available
# to users
devtools::document()
yes
Y
setwd("/Users/jessi/Desktop/Jessi/Uni/Master/4.Semester/Programming 2/My own wordle/Witmer-GermanWordle/GermanWordle")
# 7. your package can now be installed (by you and others!)
rm(list = ls())
devtools::install()
library(GermanWordle)
# 4.1 Define which functions should be available to your users
# use "#' @export" for that, add it to your .R function file
# 4.2 Use the document() function to make the functions available
# to users
devtools::document()
# 4.1 Define which functions should be available to your users
# use "#' @export" for that, add it to your .R function file
# 4.2 Use the document() function to make the functions available
# to users
devtools::document()
# 6. build your package
# creates an installable file with ending "tar.gz"
devtools::build()
# 7. your package can now be installed (by you and others!)
rm(list = ls())
devtools::install()
library(GermanWordle)
?GermanWordle
?compare_words
# 4.1 Define which functions should be available to your users
# use "#' @export" for that, add it to your .R function file
# 4.2 Use the document() function to make the functions available
# to users
devtools::document()
# 4.1 Define which functions should be available to your users
# use "#' @export" for that, add it to your .R function file
# 4.2 Use the document() function to make the functions available
# to users
devtools::document()
# 7. your package can now be installed (by you and others!)
rm(list = ls())
